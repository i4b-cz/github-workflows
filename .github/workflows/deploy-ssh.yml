name: Deploy via SSH

on:
  workflow_call:
    inputs:
      environment:
        description: 'GitHub environment (staging/production)'
        type: string
        required: true
      node-version:
        description: 'Node.js version for frontend build'
        type: string
        default: '20'
      deploy-config:
        description: 'JSON configuration for deployment'
        type: string
        required: true
        # Expected structure:
        # {
        #   "backend": { "enabled": true, "path": "./backend", "rsync-exclude": [...], "public-includes": ["index.php", ".htaccess", "cron/"] },
        #   "frontend": { "enabled": true, "path": "./frontend", "build-command": "npm run build", "post-build-commands": [...], "deploy-to": "backend/public/", "rsync-exclude": [...], "env-vars": true },
        #   "backup": { "enabled": false, "database": true, "commit-hash": true },
        #   "health-check": { "enabled": true, "url": "/api/config", "verify-production-mode": false },
        #   "post-deploy": { "composer-install": true, "run-migrations": true, "clear-cache": true, "restart-workers": false, "custom-commands": [] }
        # }

    secrets:
      SSH_KEY:
        description: 'SSH private key for deployment'
        required: true

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Parse deploy config
        id: config
        env:
          DEPLOY_CONFIG: ${{ inputs.deploy-config }}
        run: |
          # Use env var to avoid shell injection from JSON content
          CONFIG="$DEPLOY_CONFIG"

          # Backend config
          echo "backend-enabled=$(echo "$CONFIG" | jq -r '.backend.enabled // true')" >> $GITHUB_OUTPUT
          echo "backend-path=$(echo "$CONFIG" | jq -r '.backend.path // "./backend"')" >> $GITHUB_OUTPUT

          # Frontend config
          echo "frontend-enabled=$(echo "$CONFIG" | jq -r '.frontend.enabled // true')" >> $GITHUB_OUTPUT
          echo "frontend-path=$(echo "$CONFIG" | jq -r '.frontend.path // "./frontend"')" >> $GITHUB_OUTPUT
          echo "frontend-build-command=$(echo "$CONFIG" | jq -r '.frontend["build-command"] // "npm run build"')" >> $GITHUB_OUTPUT
          echo "frontend-deploy-to=$(echo "$CONFIG" | jq -r '.frontend["deploy-to"] // "backend/public/"')" >> $GITHUB_OUTPUT
          echo "frontend-env-vars=$(echo "$CONFIG" | jq -r '.frontend["env-vars"] // true')" >> $GITHUB_OUTPUT

          # Backup config
          echo "backup-enabled=$(echo "$CONFIG" | jq -r '.backup.enabled // false')" >> $GITHUB_OUTPUT
          echo "backup-database=$(echo "$CONFIG" | jq -r '.backup.database // true')" >> $GITHUB_OUTPUT

          # Health check config
          echo "healthcheck-enabled=$(echo "$CONFIG" | jq -r '.["health-check"].enabled // true')" >> $GITHUB_OUTPUT
          echo "healthcheck-url=$(echo "$CONFIG" | jq -r '.["health-check"].url // "/api/config"')" >> $GITHUB_OUTPUT
          echo "healthcheck-verify-production=$(echo "$CONFIG" | jq -r '.["health-check"]["verify-production-mode"] // false')" >> $GITHUB_OUTPUT

          # Post-deploy config
          echo "postdeploy-composer=$(echo "$CONFIG" | jq -r '.["post-deploy"]["composer-install"] // true')" >> $GITHUB_OUTPUT
          echo "postdeploy-migrations=$(echo "$CONFIG" | jq -r '.["post-deploy"]["run-migrations"] // true')" >> $GITHUB_OUTPUT
          echo "postdeploy-cache=$(echo "$CONFIG" | jq -r '.["post-deploy"]["clear-cache"] // true')" >> $GITHUB_OUTPUT
          echo "postdeploy-workers=$(echo "$CONFIG" | jq -r '.["post-deploy"]["restart-workers"] // false')" >> $GITHUB_OUTPUT

          # Store rsync excludes and other config lists as files for later use
          echo "$CONFIG" | jq -r '.backend["rsync-exclude"] // [".git", "node_modules", "vendor", "var/cache", "var/log", "var/pdf", "public/"] | .[]' > /tmp/rsync-excludes.txt
          echo "$CONFIG" | jq -r '.backend["public-includes"] // ["index.php"] | .[]' > /tmp/public-includes.txt
          echo "$CONFIG" | jq -r '.frontend["rsync-exclude"] // [] | .[]' > /tmp/frontend-rsync-excludes.txt
          echo "$CONFIG" | jq -r '.frontend["post-build-commands"] // [] | .[]' > /tmp/post-build-commands.txt
          echo "$CONFIG" | jq -r '.["post-deploy"]["custom-commands"] // [] | .[]' > /tmp/custom-commands.txt

      - name: Setup Node.js
        if: steps.config.outputs.frontend-enabled == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
          cache: 'npm'
          cache-dependency-path: ${{ steps.config.outputs.frontend-path }}/package-lock.json

      - name: Install frontend dependencies
        if: steps.config.outputs.frontend-enabled == 'true'
        working-directory: ${{ steps.config.outputs.frontend-path }}
        run: npm ci

      - name: Build frontend
        if: steps.config.outputs.frontend-enabled == 'true'
        working-directory: ${{ steps.config.outputs.frontend-path }}
        env:
          VITE_API_BASE_URL: ${{ vars.API_URL }}
          VITE_API_KEY: ${{ secrets.API_KEY }}
          BUILD_COMMAND: ${{ steps.config.outputs.frontend-build-command }}
          CREATE_ENV_VARS: ${{ steps.config.outputs.frontend-env-vars }}
        run: |
          # Create .env.production with VITE variables (optional, enabled by default)
          if [ "$CREATE_ENV_VARS" == "true" ]; then
            echo "VITE_API_BASE_URL=$VITE_API_BASE_URL" > .env.production
            if [ -n "$VITE_API_KEY" ]; then
              echo "VITE_API_KEY=$VITE_API_KEY" >> .env.production
            fi
          fi

          # Run build (command from config via env var for safety)
          echo "→ Running: $BUILD_COMMAND"
          $BUILD_COMMAND

          # Run post-build commands (from config file, validated by jq)
          if [ -s /tmp/post-build-commands.txt ]; then
            echo "Running post-build commands..."
            while IFS= read -r cmd; do
              if [ -n "$cmd" ]; then
                echo "→ $cmd"
                # Execute command - caller is responsible for safe commands
                bash -c "$cmd"
              fi
            done < /tmp/post-build-commands.txt
          fi

      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deploy-config
          path: ./deploy-artifacts
        continue-on-error: true

      - name: Move artifacts to correct locations
        run: |
          echo "→ Looking for deployment artifacts..."
          echo "  Backend path: ${{ steps.config.outputs.backend-path }}"

          if [ -d "./deploy-artifacts" ]; then
            echo "  Artifact directory contents:"
            find ./deploy-artifacts -type f | head -20

            # Move .env.local if exists (preferred for Symfony)
            if [ -f "./deploy-artifacts/backend/.env.local" ]; then
              cp ./deploy-artifacts/backend/.env.local ${{ steps.config.outputs.backend-path }}/.env.local
              echo "✓ Copied .env.local from backend/"
            elif [ -f "./deploy-artifacts/.env.local" ]; then
              cp ./deploy-artifacts/.env.local ${{ steps.config.outputs.backend-path }}/.env.local
              echo "✓ Copied .env.local from root"
            # Fallback to .env.prod.local for backwards compatibility
            elif [ -f "./deploy-artifacts/backend/.env.prod.local" ]; then
              cp ./deploy-artifacts/backend/.env.prod.local ${{ steps.config.outputs.backend-path }}/.env.local
              echo "✓ Copied .env.prod.local as .env.local from backend/"
            elif [ -f "./deploy-artifacts/.env.prod.local" ]; then
              cp ./deploy-artifacts/.env.prod.local ${{ steps.config.outputs.backend-path }}/.env.local
              echo "✓ Copied .env.prod.local as .env.local from root"
            else
              echo "⚠ No .env.local or .env.prod.local found in artifacts"
            fi

            # Move JWT keys if exist
            if [ -d "./deploy-artifacts/backend/config/jwt" ]; then
              mkdir -p ${{ steps.config.outputs.backend-path }}/config/jwt
              cp ./deploy-artifacts/backend/config/jwt/*.pem ${{ steps.config.outputs.backend-path }}/config/jwt/ 2>/dev/null || true
              echo "✓ Copied JWT keys from backend/config/jwt/"
            elif [ -d "./deploy-artifacts/config/jwt" ]; then
              mkdir -p ${{ steps.config.outputs.backend-path }}/config/jwt
              cp ./deploy-artifacts/config/jwt/*.pem ${{ steps.config.outputs.backend-path }}/config/jwt/ 2>/dev/null || true
              echo "✓ Copied JWT keys from config/jwt/"
            else
              echo "⚠ No JWT keys found in artifacts"
            fi
          else
            echo "⚠ No deploy-artifacts directory found (artifact download may have failed)"
          fi

      - name: Configure SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_KEY }}
          SSH_HOST: ${{ vars.SSH_HOST }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts

      - name: Create backup
        if: steps.config.outputs.backup-enabled == 'true'
        env:
          SSH_HOST: ${{ vars.SSH_HOST }}
          SSH_USER: ${{ vars.SSH_USER }}
          SSH_PORT: ${{ vars.SSH_PORT }}
          REMOTE_PATH: ${{ vars.REMOTE_PATH }}
          BACKUP_DATABASE: ${{ steps.config.outputs.backup-database }}
        run: |
          echo "→ Creating backup..."
          ssh -i ~/.ssh/deploy_key -p $SSH_PORT $SSH_USER@$SSH_HOST "bash -s" << 'EOF'
            set -e

            BACKUP_DIR="$REMOTE_PATH/../backups"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            BACKUP_NAME="backup_${TIMESTAMP}"

            mkdir -p "$BACKUP_DIR"

            # Save current commit
            cd $REMOTE_PATH
            if [ -d ".git" ]; then
              git rev-parse --short HEAD > "$BACKUP_DIR/${BACKUP_NAME}_commit.txt" 2>/dev/null || echo "unknown" > "$BACKUP_DIR/${BACKUP_NAME}_commit.txt"
            fi

            # Backup database if enabled
            if [ "$BACKUP_DATABASE" == "true" ] && [ -f "$REMOTE_PATH/backend/.env.local" ]; then
              cd $REMOTE_PATH/backend
              source .env.local 2>/dev/null || true

              if [ -n "$DATABASE_URL" ]; then
                DB_USER=$(echo $DATABASE_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
                DB_PASS=$(echo $DATABASE_URL | sed -n 's/.*:\/\/[^:]*:\([^@]*\)@.*/\1/p')
                DB_HOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:\/]*\).*/\1/p')
                DB_NAME=$(echo $DATABASE_URL | sed -n 's/.*\/\([^?]*\).*/\1/p')

                if [ -n "$DB_NAME" ]; then
                  mysqldump -u"$DB_USER" -p"$DB_PASS" -h"$DB_HOST" "$DB_NAME" > "$BACKUP_DIR/${BACKUP_NAME}_database.sql" 2>/dev/null || echo "DB backup warning"
                  echo "✓ Database backup created"
                fi
              fi
            fi

            echo "✓ Backup created: $BACKUP_NAME"
          EOF

      - name: Deploy frontend
        if: steps.config.outputs.frontend-enabled == 'true'
        env:
          SSH_HOST: ${{ vars.SSH_HOST }}
          SSH_USER: ${{ vars.SSH_USER }}
          SSH_PORT: ${{ vars.SSH_PORT }}
          REMOTE_PATH: ${{ vars.REMOTE_PATH }}
        run: |
          # Build frontend rsync exclude arguments from config
          FRONTEND_EXCLUDE_ARGS=()
          if [ -s /tmp/frontend-rsync-excludes.txt ]; then
            while IFS= read -r exclude; do
              if [ -n "$exclude" ]; then
                FRONTEND_EXCLUDE_ARGS+=("--exclude=$exclude")
              fi
            done < /tmp/frontend-rsync-excludes.txt
          fi

          rsync -avz --delete --mkpath \
            -e "ssh -i ~/.ssh/deploy_key -p $SSH_PORT" \
            "${FRONTEND_EXCLUDE_ARGS[@]}" \
            ${{ steps.config.outputs.frontend-path }}/dist/ \
            $SSH_USER@$SSH_HOST:$REMOTE_PATH/${{ steps.config.outputs.frontend-deploy-to }}

      - name: Deploy backend
        if: steps.config.outputs.backend-enabled == 'true'
        env:
          SSH_HOST: ${{ vars.SSH_HOST }}
          SSH_USER: ${{ vars.SSH_USER }}
          SSH_PORT: ${{ vars.SSH_PORT }}
          REMOTE_PATH: ${{ vars.REMOTE_PATH }}
          BACKEND_PATH: ${{ steps.config.outputs.backend-path }}
        run: |
          # Build rsync exclude arguments safely using array
          EXCLUDE_ARGS=()
          while IFS= read -r exclude; do
            if [ -n "$exclude" ]; then
              EXCLUDE_ARGS+=("--exclude=$exclude")
            fi
          done < /tmp/rsync-excludes.txt

          # Deploy backend code (using array expansion for safety)
          rsync -avz --delete --mkpath \
            -e "ssh -i ~/.ssh/deploy_key -p $SSH_PORT" \
            "${EXCLUDE_ARGS[@]}" \
            "$BACKEND_PATH/" \
            "$SSH_USER@$SSH_HOST:$REMOTE_PATH/backend/"

          # Deploy public/ includes from config (default: index.php)
          while IFS= read -r item; do
            if [ -n "$item" ]; then
              if [ -f "$BACKEND_PATH/public/$item" ]; then
                echo "→ Deploying public/$item"
                rsync -avz \
                  -e "ssh -i ~/.ssh/deploy_key -p $SSH_PORT" \
                  "$BACKEND_PATH/public/$item" \
                  "$SSH_USER@$SSH_HOST:$REMOTE_PATH/backend/public/$item"
              elif [ -d "$BACKEND_PATH/public/$item" ]; then
                echo "→ Deploying public/$item/"
                rsync -avz \
                  -e "ssh -i ~/.ssh/deploy_key -p $SSH_PORT" \
                  "$BACKEND_PATH/public/$item/" \
                  "$SSH_USER@$SSH_HOST:$REMOTE_PATH/backend/public/$item/"
              fi
            fi
          done < /tmp/public-includes.txt

          # Deploy .env.local if exists
          if [ -f "$BACKEND_PATH/.env.local" ]; then
            echo "→ Deploying .env.local..."
            rsync -avz \
              -e "ssh -i ~/.ssh/deploy_key -p $SSH_PORT" \
              "$BACKEND_PATH/.env.local" \
              "$SSH_USER@$SSH_HOST:$REMOTE_PATH/backend/.env.local"
            echo "✓ .env.local deployed"
          else
            echo "⚠ No .env.local found at $BACKEND_PATH/.env.local"
          fi

          # Deploy JWT keys if exist
          if [ -d "$BACKEND_PATH/config/jwt" ]; then
            ssh -i ~/.ssh/deploy_key -p $SSH_PORT "$SSH_USER@$SSH_HOST" "mkdir -p $REMOTE_PATH/backend/config/jwt"
            rsync -avz \
              -e "ssh -i ~/.ssh/deploy_key -p $SSH_PORT" \
              "$BACKEND_PATH/config/jwt/" \
              "$SSH_USER@$SSH_HOST:$REMOTE_PATH/backend/config/jwt/"
            ssh -i ~/.ssh/deploy_key -p $SSH_PORT "$SSH_USER@$SSH_HOST" "chmod 600 $REMOTE_PATH/backend/config/jwt/*.pem 2>/dev/null || true"
          fi

          echo "✓ Backend deployed"

      - name: Run post-deploy tasks
        env:
          SSH_HOST: ${{ vars.SSH_HOST }}
          SSH_USER: ${{ vars.SSH_USER }}
          SSH_PORT: ${{ vars.SSH_PORT }}
          REMOTE_PATH: ${{ vars.REMOTE_PATH }}
          DO_COMPOSER: ${{ steps.config.outputs.postdeploy-composer }}
          DO_MIGRATIONS: ${{ steps.config.outputs.postdeploy-migrations }}
          DO_CACHE: ${{ steps.config.outputs.postdeploy-cache }}
          DO_WORKERS: ${{ steps.config.outputs.postdeploy-workers }}
        run: |
          # Copy custom commands to remote
          CUSTOM_COMMANDS=$(cat /tmp/custom-commands.txt | tr '\n' ';')

          ssh -i ~/.ssh/deploy_key -p $SSH_PORT $SSH_USER@$SSH_HOST "bash -s" << EOF
            set -e

            cd $REMOTE_PATH/backend

            if [ "$DO_COMPOSER" == "true" ]; then
              echo "→ Installing dependencies..."
              composer install --no-dev --optimize-autoloader --no-interaction --no-scripts
            fi

            if [ "$DO_MIGRATIONS" == "true" ]; then
              echo "→ Running migrations..."
              APP_ENV=prod php bin/console doctrine:migrations:migrate --no-interaction --allow-no-migration
            fi

            if [ "$DO_CACHE" == "true" ]; then
              echo "→ Clearing cache..."
              APP_ENV=prod php bin/console cache:clear --no-debug
              APP_ENV=prod php bin/console cache:warmup --no-debug
            fi

            echo "→ Fixing permissions..."
            chmod -R 775 var/cache var/log 2>/dev/null || true

            if [ "$DO_WORKERS" == "true" ]; then
              echo "→ Restarting workers..."
              supervisorctl restart messenger-consume:* 2>/dev/null || echo "Supervisor not available"
            fi

            # Run custom commands
            if [ -n "$CUSTOM_COMMANDS" ]; then
              echo "→ Running custom commands..."
              IFS=';' read -ra CMDS <<< "$CUSTOM_COMMANDS"
              for cmd in "\${CMDS[@]}"; do
                if [ -n "\$cmd" ]; then
                  echo "  → \$cmd"
                  eval "\$cmd"
                fi
              done
            fi

            echo "✓ Post-deploy tasks completed"
          EOF

      - name: Health check
        if: steps.config.outputs.healthcheck-enabled == 'true'
        env:
          APP_URL: ${{ vars.APP_URL }}
          HEALTH_URL: ${{ steps.config.outputs.healthcheck-url }}
          VERIFY_PRODUCTION: ${{ steps.config.outputs.healthcheck-verify-production }}
        run: |
          sleep 5

          FULL_URL="${APP_URL}${HEALTH_URL}"
          echo "→ Checking $FULL_URL..."

          HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "$FULL_URL")

          if [ "$HTTP_CODE" = "200" ]; then
            echo "✓ API is healthy (HTTP $HTTP_CODE)"

            # Verify production mode if enabled
            if [ "$VERIFY_PRODUCTION" == "true" ]; then
              RESPONSE=$(cat /tmp/health_response.txt)
              TESTING_MODE=$(echo "$RESPONSE" | grep -o '"testing_mode":[^,}]*' | cut -d':' -f2 | tr -d ' ')

              if [ "$TESTING_MODE" = "false" ]; then
                echo "✓ Production mode confirmed (testing_mode: false)"
              else
                echo "✗ WARNING: testing_mode is not false!"
                exit 1
              fi
            fi
          else
            echo "✗ Health check failed (HTTP $HTTP_CODE)"
            cat /tmp/health_response.txt
            exit 1
          fi

          # Check frontend
          echo "→ Checking frontend at $APP_URL/..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL/")

          if [ "$HTTP_CODE" = "200" ]; then
            echo "✓ Frontend is accessible (HTTP $HTTP_CODE)"
          else
            echo "⚠ Frontend returned HTTP $HTTP_CODE"
          fi

      - name: Deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "================================================"
            echo "✓ DEPLOYMENT SUCCESSFUL"
            echo "================================================"
            echo "Environment: ${{ inputs.environment }}"
            echo "URL: ${{ vars.APP_URL }}"
          else
            echo "✗ DEPLOYMENT FAILED"
            echo "Environment: ${{ inputs.environment }}"
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f /tmp/rsync-excludes.txt /tmp/public-includes.txt /tmp/frontend-rsync-excludes.txt /tmp/post-build-commands.txt /tmp/custom-commands.txt /tmp/health_response.txt
